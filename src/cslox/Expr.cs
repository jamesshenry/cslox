// This file is generated by cslox.tool. Do not edit it manually.
using System.Diagnostics.Contracts;
using System.Text;

namespace cslox;

public abstract record Expr
{
    public interface IVisitor<T>
    {
        public abstract T Visit(Binary expr);
        public abstract T Visit(Grouping expr);
        public abstract T Visit(Literal expr);
        public abstract T Visit(Unary expr);
    }

    public record Binary(Expr Left, Token Operator, Expr Right) : Expr
    {
        public override T Accept<T>(IVisitor<T> visitor)
        {
            return visitor.Visit(this);
        }
    }

    public record Grouping(Expr Expression) : Expr
    {
        public override T Accept<T>(IVisitor<T> visitor)
        {
            return visitor.Visit(this);
        }
    }

    public record Literal(object Value) : Expr
    {
        public override T Accept<T>(IVisitor<T> visitor)
        {
            return visitor.Visit(this);
        }
    }

    public record Unary(Token Operator, Expr Right) : Expr
    {
        public override T Accept<T>(IVisitor<T> visitor)
        {
            return visitor.Visit(this);
        }
    }

    public abstract T Accept<T>(IVisitor<T> visitor);
}

public class AstPrinter : Expr.IVisitor<string>
{
    public string Print(Expr expr) => expr.Accept(this);

    public string Visit(Expr.Binary expr) =>
        Parenthesize(expr.Operator.Lexeme, expr.Left, expr.Right);

    public string Visit(Expr.Grouping expr) => Parenthesize("group", expr.Expression);

    public string Visit(Expr.Literal expr) => expr.Value?.ToString() ?? "nil";

    public string Visit(Expr.Unary expr) => Parenthesize(expr.Operator.Lexeme, expr.Right);

    string Parenthesize(string name, params Expr[] exprs)
    {
        var builder = new StringBuilder();

        builder.Append('(').Append(name);
        foreach (var expr in exprs)
        {
            builder.Append(' ').Append(expr.Accept(this));
        }

        builder.Append(')');

        return builder.ToString();
    }
}

public class RpnPrinter : Expr.IVisitor<string>
{
    public string Print(Expr expr) => expr.Accept(this);

    public string Visit(Expr.Binary expr) => ToRpn(expr.Operator.Lexeme, expr.Left, expr.Right);

    public string Visit(Expr.Grouping expr) => expr.Expression.Accept(this);

    public string Visit(Expr.Literal expr) => expr.Value?.ToString() ?? "nil";

    public string Visit(Expr.Unary expr) =>
        expr.Operator.Type == TokenType.MINUS
            ? $"{expr.Right.Accept(this)} ~"
            : $"{expr.Right.Accept(this)} {expr.Operator.Lexeme}";

    private string ToRpn(string name, params Expr[] exprs)
    {
        var builder = new StringBuilder();

        foreach (var expr in exprs)
        {
            builder.Append(expr.Accept(this)).Append(' ');
        }
        builder.Append(name);

        return builder.ToString();
    }
}
